---
title: 'Test Driven Development'
subtitle: 'Test mi? Ben testÃ§i deÄŸilim ki!'
author: Burak
avatar: img/authors/wferr.png
image: img/a.jpg
---

BirkaÃ§ yÄ±ldÄ±r gÃ¼n geÃ§tikÃ§e daha fazla karÅŸÄ±laÅŸmaya baÅŸladÄ±ÄŸÄ±m bu konu hakkÄ±nda bir hayli ilgim artmÄ±ÅŸtÄ±. Ben de bu yeni metodoloji neler sÃ¶ylÃ¼yor bir araÅŸtÄ±rayÄ±m dedim.Ã–ncelikle Ã§oÄŸu yerde de â€œTDDâ€ kÄ±saltmasÄ±yla gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z bu metodolojinin tÃ¼rkÃ§e karÅŸÄ±lÄ±ÄŸÄ± test gÃ¼dÃ¼mlÃ¼ geliÅŸtirmedir. O halde Ã¼zerine biraz dÃ¼ÅŸÃ¼nÃ¼rsek karÅŸÄ±mÄ±za â€œÃ–nce test et, sonra kod yazâ€ gibi bir mantalite Ã§Ä±kÄ±yor. Bunu ilk dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼mde Ã§ok mantÄ±klÄ± bulmadÄ±ÄŸÄ±mÄ± sÃ¶ylemeliyim. Hem henÃ¼z yazmadÄ±ÄŸÄ±m kod iÃ§in bir test oluÅŸturmak Ã§ok bÃ¼yÃ¼k bir zaman kaybÄ± deÄŸil miydi ?


Bu dÃ¼ÅŸÃ¼ncelerim nedeniyle tam anlamÄ±yla test gÃ¼dÃ¼mlÃ¼ geliÅŸtirmeye yaklaÅŸmayÄ± dÃ¼ÅŸÃ¼nmedim. Fakat popÃ¼lerleÅŸmeye baÅŸladÄ±kÃ§a merakÄ±m, Ã¶n yargÄ±mÄ± yendi ve enine boyuna bu metedolojiyi inceledim. Åimdi gÃ¶rÃ¼yorum ki aslÄ±nda hiÃ§te zaman kaybettirmiyor aksine uzun vadede size zaman kazandÄ±rÄ±yor. Peki bu nasÄ±l oluyor ? NasÄ±l oluyor da biz test yazmadan daha Ã§ok  vakit kaybediyoruz ? Ã–ncelikle iÅŸin mantÄ±ÄŸÄ±na inelim. Test gÃ¼dÃ¼mlÃ¼ geliÅŸtirme, kÃ¼Ã§Ã¼k adÄ±mlÄ± yazÄ±lÄ±m geliÅŸtirme dÃ¶ngÃ¼lerinden oluÅŸuyor. Test gÃ¼dÃ¼mlÃ¼ geliÅŸtirme yaparken her bir sÄ±nÄ±fÄ±mÄ±z iÃ§in ayrÄ± ayrÄ± birim testler yazarÄ±z ve ardÄ±ndan bu testi geÃ§ebilecek kodumuzu yazarÄ±z daha sonra yazdÄ±ÄŸÄ±mÄ±z kodu iyileÅŸtirmek adÄ±na deÄŸiÅŸiklikler yaparÄ±z. Her test bu dÃ¶ngÃ¼nÃ¼n bir halkasÄ±nÄ± tamamlar. TÃ¼m testleri tamamladÄ±ÄŸÄ±mÄ±zda ise elimizde gereksinimlerimizi karÅŸÄ±layan kodlar olacaktÄ±r. AsÄ±l meselede buradan sonra baÅŸlayacak olandÄ±r. Uzun bir zaman sonra kendi yazdÄ±ÄŸÄ±mÄ±z koda bakÄ±p yabancÄ±lÄ±k Ã§ektiÄŸimizde saatlerce hatta bazen gÃ¼nlerce basit bir problemin nedenini araÅŸtÄ±rÄ±yoruz. Oysa ki TDD ile bu durum sorun olmaktan Ã§Ä±kÄ±yor. Ã‡Ã¼nkÃ¼ elimizde projenin birim testleri var ve bu testleri Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda sorun nerede kolaylÄ±kla gÃ¶rebiliyoruz. Bunun yanÄ±nda eÄŸer test gÃ¼dÃ¼mlÃ¼ geliÅŸtirme yÃ¶ntemini kullanÄ±yorsanÄ±z doÄŸal olarak test edilebilir kodlar oluÅŸturuyorsunuz. Bir kodun da test edilebilirliÄŸi ne kadar fazla ise kodun iÃ§erisindeki sÄ±nÄ±flarÄ±n birbirleriyle olan baÄŸÄ±lÄ±lÄ±ÄŸÄ± o kadar azdÄ±r. BÃ¶ylece nesne yÃ¶nelimli programlamanÄ±n temel amaÃ§larÄ±ndan biri olan  â€œhigh cohesion and loose couplingâ€ ilkesine de  hizmet etmiÅŸ olursunuz. AyrÄ±ca bu tarz bir yÃ¶ntemle geliÅŸtirilmiÅŸ yazÄ±lÄ±mda, tasarÄ±m iyileÅŸtirme faaliyetleri daha kolay ve gÃ¼venli gerÃ§ekleÅŸtirilir. Ã‡Ã¼nkÃ¼ kodda yaptÄ±ÄŸÄ±mÄ±z her bir deÄŸiÅŸiklikte tÃ¼m birim testlerini koÅŸturarak yaptÄ±ÄŸÄ± deÄŸiÅŸikliÄŸin herhangi bir gereksinimi ezilip ezmediÄŸini kontrol edebilecektir.


Tamam, test yazmak mantÄ±klÄ±, test yazmaya karÅŸÄ± deÄŸiliz ama neden daha Ã¶nce test yazayÄ±m diye sorabilirsiniz. Bende aynÄ± soruyu sormuÅŸtum Ã§Ã¼nkÃ¼ ğŸ™‚

Testleri daha Ã¶nce yazmamÄ±z Ã¶nÃ¼mÃ¼zÃ¼ daha iyi gÃ¶rmemiz ve daha iyi bir kurgu oluÅŸturmamÄ±za olanak saÄŸlar ki zaten kod yazmadan testini yazabiliyorsanÄ±z kafanÄ±zda kurguyu tamamlamÄ±ÅŸsÄ±nÄ±zdÄ±r. KafanÄ±zda oturmuÅŸ bir kurgu da kodunuzun en ince ayrÄ±ntÄ±lara kadar planlamalarÄ±nÄ± yaptÄ±ÄŸÄ±nÄ±zÄ± gÃ¶sterir. Bu sayede de daha nitelikli kod yazmÄ±ÅŸ olursunuz.Bu konuyu da Paul Grahamâ€™Ä±n â€œProgramlar yazÄ±lÄ±rken ÅŸekillendirilmelidir; tÄ±pkÄ± yazarlar, ressamlar ve mimarlarÄ±n yaptÄ±ÄŸÄ± gibi.â€  sÃ¶zleriyle Ã§okta uzatmadan bitirelim.

Åimdi de gelelim teoride olayÄ±n nasÄ±l iÅŸlediÄŸineâ€¦

Test gÃ¼dÃ¼mlÃ¼ geliÅŸtirme Ã¼Ã§ aÅŸamadan oluÅŸuyor, bunlar;

### Red:
Ä°mplementasyona deÄŸil gereksinime odaklan: Bu aÅŸamada geliÅŸtirici kendisine verilmiÅŸ gereksinimlerden sÄ±radaki gereksinime ait birim testi yazar. YazÄ±lan test, daha Ã¶ncesinden yazÄ±lmÄ±ÅŸ olan tÃ¼m birime testlerle birlikte Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. En son yazÄ±lan birim teste ait implementasyon henÃ¼z yapÄ±lmadÄ±ÄŸÄ± iÃ§in ilgili test baÅŸarÄ±sÄ±z (Red) sonuÃ§lanÄ±r.

### Green:
Basit dÃ¼ÅŸÃ¼n basit yap: GeliÅŸtirici, gereksinimi karÅŸÄ±layacak yazÄ±lÄ±mÄ±n implementasyonu en az kodla yapar. YazÄ±lan kodun sadece ÅŸimdiye kadar birim testi yazÄ±lmÄ±ÅŸ gereksinimleri karÅŸÄ±lamasÄ± beklenir. Gelecekte yazÄ±lÄ±mÄ± yapÄ±lacak durumlarÄ±n kodlamasÄ± Ã¶nceden yazÄ±lmaz ve dÃ¼ÅŸÃ¼nÃ¼lmez. Implementasyon tamamlandÄ±ktan sonra yazÄ±lÄ±mÄ±n gereksinimi karÅŸÄ±layÄ±p karÅŸÄ±lamadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in tÃ¼m birim testler Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. Beklenen durum tÃ¼m birim testlerinin baÅŸarÄ±yla geÃ§mesidir. Bu testler baÅŸarÄ±yla koÅŸtuÄŸu takdirde yazÄ±lÄ±mcÄ± bir sonraki aÅŸamaya geÃ§ebilir aksi takdirde gereksinim ile yazÄ±lÄ±m arasÄ±nda uyumsuzluk olduÄŸunu gÃ¶sterir.

### Refactor:
TasarÄ±mÄ±nÄ± iyileÅŸtir: GeliÅŸtirici, bu aÅŸamada testlerinde deÄŸiÅŸiklik yapmadan kodunu yeniden gÃ¶zden geÃ§irerek tasarÄ±mÄ±nÄ± iyileÅŸtirmeye Ã§alÄ±ÅŸÄ±r. Bu kapsamda geliÅŸtirici kullandÄ±ÄŸÄ± methot, deÄŸiÅŸken ve sÄ±nÄ±f isimlerini dÃ¼zenler. Var olan kod tekrarlarÄ±nÄ± giderir ve kodunu daha test edilebilir hale getirir. BÃ¶ylece kodunun baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± azaltÄ±rken amaca yÃ¶nelik methot ve sÄ±nÄ±flarÄ±n ortaya Ã§Ä±kmasÄ±nÄ± saÄŸlar. Bu aÅŸamada dikkat edilmesi gereken nokta deÄŸiÅŸikliklerin adÄ±m adÄ±m yapÄ±lmasÄ±dÄ±r. AyrÄ±ca her bir adÄ±mda yazÄ±lÄ±mÄ±n derlenebiliyor olmasÄ±na Ã¶zen gÃ¶stermelidir. Bununla birlikte yazÄ±lÄ±mcÄ± her deÄŸiÅŸiklik adÄ±mÄ±nda tÃ¼m testleri Ã§alÄ±ÅŸtÄ±rarak testlerin baÅŸarÄ±yla geÃ§tiÄŸinden emin olmalÄ±dÄ±r. Testler geÃ§mediÄŸi sÃ¼rece yeni deÄŸiÅŸiklikler yapmamalÄ±dÄ±r.

BugÃ¼nlÃ¼k test gÃ¼dÃ¼mlÃ¼ geliÅŸtirmenin ne olduÄŸundan, neden Ã¶nemli olduÄŸundan ve nasÄ±l kullanÄ±ldÄ±ÄŸÄ±ndan bahsetmeye Ã§alÄ±ÅŸtÄ±m. Bir sonraki yazÄ±mda Ã¶rnek Ã§alÄ±ÅŸmalarla birlikte test gÃ¼dÃ¼mlÃ¼ geliÅŸtirmeyi detaylÄ± bir incelemeye alacaÄŸÄ±m.
